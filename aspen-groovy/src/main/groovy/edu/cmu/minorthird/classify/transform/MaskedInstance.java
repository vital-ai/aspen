package edu.cmu.minorthird.classify.transform;import java.util.Iterator;import java.util.Set;import java.util.SortedMap;import java.util.SortedSet;import java.util.TreeSet;import edu.cmu.minorthird.classify.AbstractInstance;import edu.cmu.minorthird.classify.Feature;import edu.cmu.minorthird.classify.Instance;import edu.cmu.minorthird.classify.WeightedSet;import edu.cmu.minorthird.util.UnionIterator;/** * @author Edoardo Airoldi * Date: Dec 5, 2003 */public class MaskedInstance extends AbstractInstance{	// static private Logger log=Logger.getLogger(MaskedInstance.class);	private Instance instance;	private Set<Feature> available;	public MaskedInstance(Instance instance,Set<Feature> availableFeatures){		this.instance=instance;		this.available=availableFeatures;	}		public MaskedInstance(Instance instance,SortedMap<Feature,?> availableFeatures){		this(instance,availableFeatures.keySet());	}	final public Object getSource(){		return instance.getSource();	}	final public String getSubpopulationId(){		return instance.getSubpopulationId();	}	//	// extend the binary feature set	//	public double getWeight(Feature f){		if(available.contains(f))			return instance.getWeight(f);		else			return 0.0;	}	/** Return an iterator over all available features */	public Iterator<Feature> featureIterator(){		SortedSet<Feature> set=new TreeSet<Feature>();		WeightedSet<Feature> wset=new WeightedSet<Feature>();		for(Iterator<Feature> i=instance.binaryFeatureIterator();i.hasNext();){			Feature f=i.next();			if(available.contains(f)){				set.add(f);			}		}		for(Iterator<Feature> i=instance.numericFeatureIterator();i.hasNext();){			Feature f=i.next();			if(available.contains(f)){				wset.add(f,instance.getWeight(f));			}		}		return new UnionIterator<Feature>(set.iterator(),wset.asSet().iterator());	}	/** Return an iterator over numeric features */	final public Iterator<Feature> numericFeatureIterator(){		WeightedSet<Feature> wset=new WeightedSet<Feature>();		for(Iterator<Feature> i=instance.numericFeatureIterator();i.hasNext();){			Feature f=i.next();			if(available.contains(f)){				wset.add(f,instance.getWeight(f));			}		}		return wset.asSet().iterator();	}	/** Return an iterator over binary features */	final public Iterator<Feature> binaryFeatureIterator(){		SortedSet<Feature> set=new TreeSet<Feature>();		for(Iterator<Feature> i=instance.binaryFeatureIterator();i.hasNext();){			Feature f=i.next();			if(available.contains(f)){				set.add(f);			}		}		return set.iterator();	}	final public int numFeatures(){		System.err.println("Not implemented: numFeatures()");		return -1;	}	public String toString(){		return "[masked "+instance+" av:"+available+"]";	}}